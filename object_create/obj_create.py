# Copyright (c) Gabriel Parmer, 2024.
# Do not distribute without permission.

#!/bin/python3

# A program to take an ELF object, and output a program for the
# architecture class.
#
# Some assumptions about the input program:
#
# 1. There is no `.data` section. You *cannot* include initialized
#    global data in your C program. Add an `ecall` "syscall" to read
#    in data if necessary.
# 2. The output binary has the code at address `0`, then, optionally,
#    rounding up to a page, the global zeroed data (`.bss`).
# 3. There should be no constructors, deconstructors, nor TLS.
# 4. The stack is generated by _crt0.s, and is a page in size, if it
#    exists.
# 5. The compiled binary has no PIC/PIE/jump tables/libc (use
#    `-march=rv64i -mabi=lp64 -fno-pic -fno-PIC -fno-pie -fno-plt -ffreestanding -nostdlib -nostartfiles -nodefaultlibs -static -fno-jump-tables -Wl,--gc-sections -Wl,-T,riscv64-virt.ld`)

import subprocess
import sys
import re

OBJDUMP = "riscv64-unknown-elf-objdump"
READABLE_OUTPUT = False

def arg_exists(arg):
    return len(list(filter(lambda a: a == arg, sys.argv))) > 0

if len(sys.argv) < 2:
    print("Usage: " + sys.argv[0] + " <program> [options...]\nOptions:")
    print("\t-r: output readable output with instruction addresses.")
    exit(-1);

prog = sys.argv[1]

if arg_exists("-r"):
    READABLE_OUTPUT = True

# Simple call out to the shell. Not secure at all, so don't use in
# untrusted programs.
def run_shell(command):
    output = subprocess.run(command, shell=True, capture_output=True, text=True)
    return output.stdout

# Retrive the starting instruction address within the program.
def binary_start_address(prog):
    return run_shell(OBJDUMP + " -x " + prog + " | grep \"start address\" | sed 's/start address//g'").strip()

# return a tuple of the lower and and upper instruction addresses, the
# starting instruction address, and the upper memory address.
def binary_addresses(prog):
    # split the line into a list, filtering empty entries
    def split_line(l):
        return list(filter(lambda i: len(i) != 0, l.strip().split(' ')))

    starts = run_shell(OBJDUMP + " -x " + prog + " | grep \"off.*vaddr.*paddr\"")
    memory_start_addrs = list(map(lambda l: split_line(l)[4], starts.strip().split('\n')))
    sizes = run_shell(OBJDUMP + " -x " + prog + " | grep \"filesz.*memsz.*flags\"")
    memory_end_addrs = list(map(lambda l: split_line(l)[3], sizes.strip().split('\n')))
    spans = list(zip(memory_start_addrs, memory_end_addrs))
    if len(spans) > 2:
        print("Error: we only support code and, optionally, uninitialized data, but we found either read-only data (i.e. constant strings, or `const` data), or initialized global data in the binary: rewrite your program to only include code an uninitialized data.\nThis means that you can use `.zero` directives to create global variables, but not any directive that would initialize the data to a specific, non-zero value. It also means that you cannot use strings!")
        exit(-1)
    if len(spans) == 1:
        spans.append((str(int(spans[0][0], 0) + int(spans[0][1], 0)), "0x0")) # no BSS, so add an "empty entry" for it
    # just standardize the hex outputs
    hexify = lambda n: hex(int(n, base=0))
    return (hexify(spans[0][0]), hex(int(spans[0][0], 0) + int(spans[0][1], 0)), hexify(binary_start_address(prog)), hex(int(spans[1][0], 0) + int(spans[1][1], 0)))

# Return all of the assembly for the program, annotated with addresses
# (to make it more readable)
def program(prog, lower_addr, upper_addr):
    s = OBJDUMP + " -Mnumeric --disassembler-options=no-aliases -d " + prog + " | tail -n +6 | sed -e \"s/<.*>//g\" -e \"s/://g\" -e \"s/#.*//g\" | awk -F' ' '{ if (NF == 4 || NF == 5) { print $1 \"\t\" $3 \" \" $4;} if (NF == 3) { print $1 \"\t\" $3;} }'"
    p = run_shell(s).strip();

    # Validate that our regex above didn't drop instructions to catch
    # objdump and irregularies or our own parsing bugs.
    lines = list(filter(lambda l: len(l.strip()) != 0, p.split('\n')))
    addrs = list(map(lambda l: re.split('[ \t]', l.strip())[0], lines))
    pairs = list(zip(addrs[0:-1], addrs[1:]))
    for (n, nplus1) in pairs:
        if ((int(n, 16) + 4) != int(nplus1, 16)):
            sys.stderr.write("Error: found non-contiguous addresses in program in between instructions " + n + " and " + nplus1 + ": Likely an error in the regular expression to derive the experssions.\n")
            exit(-1)

    if READABLE_OUTPUT:
        return p

    s = OBJDUMP + " -Mnumeric --disassembler-options=no-aliases -d " + prog + " | tail -n +6 | sed -e \"s/<.*>//g\" -e \"s/://g\" -e \"s/#.*//g\" | awk -F' ' '{ if (NF == 4 || NF == 5) { print $3 \" \" $4;} if (NF == 3) { print $3;} }'"
    prog = run_shell(s).strip();
    reg = "x[0-9]+"
    hex_num = "(0[xX])?([0-9a-fA-F]+)" # sometimes hex have 0x, sometimes not, FUN!

    # This function does two things:
    #
    # 1. Convert absolute addresses into the relative addresses that
    #    the actual ISA requires. We could alternatively parse the raw
    #    binary, but the tombstone library is annoying ¯\_(ツ)_/¯.
    #
    # 2. Fix `objdump` bugs around number representations. This is a
    #    hack: objdump has a bug where it sometimes uses hex, and
    #    sometimes uses digits, AND when it uses hex, it doesn't
    #    always use 0x as a prefix. So we have to hack this to fix it
    #    -- convert all of these to digits so that we uniformly use
    #    digits in the assembly.
    def instruction_fixup(il):
        # which instruction are we processing, and what is the
        # instruction line?
        (i, l) = il
        branch_instr = lambda n: ("(" + n + " " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16) - (i * 4)))
        fixups = [
            ("(jalr " + reg + ",)" + hex_num + "([(]" + reg + "[)])", lambda m: m.group(1) + str(int(m.group(3), 10)) + m.group(4)),
            ("(auipc " + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(lui " + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(slli " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(srli " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(srai " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(slliw " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(srliw " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            ("(sraiw " + reg + "," + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16))),
            # In the following, we're converting absolute addresses
            # into relative here (with the `- (i * 4)`). This
            # calcuation assumes that instructions are `4` bytes.
            ("(jal " + reg + ",)" + hex_num, lambda m: m.group(1) + str(int(m.group(3), 16) - (i * 4))),
            branch_instr("beq"),
            branch_instr("bne"),
            branch_instr("blt"),
            branch_instr("bge"),
            branch_instr("bltu"),
            branch_instr("bgeu"),
        ]

        for (s, n) in fixups:
            m = re.search(s, l)
            if m != None:
                l = n(m)
                break
        return l

    lines = prog.split('\n');
    prog = '\n'.join([instruction_fixup(l) for l in enumerate(lines)])
    return prog

def output_program(prog, inst_lower, inst_upper, inst_start, memsz):
    print(inst_lower + " " + inst_upper + " " + inst_start + " " + memsz)
    print(prog, end='')

# lower, upper instruction addresses, start instruction address, and
# memory size.
(l, u, s, m) = binary_addresses(prog)
output_program(program(prog, l, u), l, u, s, m)
